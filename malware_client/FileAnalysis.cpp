#include "FileAnalysis.hpp"
#include "FileEncrypt.hpp"

using namespace std;



void FileRead(unsigned char* key, string& dirName)
{
    WIN32_FIND_DATAA data;
    HANDLE hFind = nullptr;

    vector<string> folders;
    vector<string> files;

    cout << "\n\n ********** " + dirName + " **********" << endl;
    hFind = FindFirstFileA((dirName + "\\*").c_str(), &data);


    if (hFind == INVALID_HANDLE_VALUE)
    {
        return;
    }

    do {
        if (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            folders.push_back(data.cFileName);
        }
        else
        {
            files.push_back(data.cFileName);
        }
    } while (FindNextFileA(hFind, &data) != 0);

    FindClose(hFind);

    // 파일 출력
    for (string& file : files)
    {
        cout << "[File] " << file << endl;
        EncryptFileByAES(key, dirName, file);
    }

    // 폴더 출력
    for (const string& folder : folders)
    {
        cout << "[Folder] " << folder << endl;
        // TODO : 폴더 재귀적으로 탐색
    }


}


void EncryptFileByAES(unsigned char* key, string& dirName, string& fileName) {

    HANDLE handle1;
    HANDLE handle2;
    DWORD size; 
    DWORD nRead;
    string name = dirName + "\\" + fileName;
    unsigned char* plain_buf;
    unsigned char* cipher_buf;

    handle1 = CreateFileA(name.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    handle2 = CreateFileA(name.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (handle1 == INVALID_HANDLE_VALUE) {
        cout << "파일 오픈 실패" << endl;
        return;
    }
    
    size = GetFileSize(handle1, NULL);
    cout << size << endl;
    plain_buf = (unsigned char*) malloc(size + 2);
    cipher_buf = (unsigned char*)malloc(size + 2);

    if (ReadFile(handle1, plain_buf, size, &nRead, NULL) != TRUE)
    {
        cout << "fail to file open " << endl;
        return;
    }
    else 
    {   
        cout << plain_buf << endl;

        // TODO : Check Length 에서 해당 숫자로 나눠지지 않는 문제 발생  => 패딩으로 해결
        //getEncryptText(plain_buf, (unsigned int)size, key, cipher_buf);
        cout << cipher_buf << endl;

        
    }
    CloseHandle(handle1);
    CloseHandle(handle2);

    free(plain_buf);
    free(cipher_buf);

}